const path = require("path"), fs = require("fs");
const IMAGES = path.resolve(__dirname, '../../images/');
var ObjectId = require('mongodb').ObjectID;

//Populamos y obtenemos treatment, reases y wholeFishWeight
const getTRW = async mainFish => {
    if (mainFish.treatment !== null && mainFish.treatment !== undefined) {
        let treatment = await Treatment.findOne({ id: mainFish.treatment });
        if (treatment !== undefined) mainFish.treatment = treatment.name;
        else mainFish.treatment = '';
    }
    else mainFish.treatment = "";

    if (mainFish.raised !== null && mainFish.raised !== undefined) {
        let raised = await Raised.findOne({ id: mainFish.raised });
        if (raised !== undefined) mainFish.raised = raised.name;
        else mainFish.raised = "";
    }
    else mainFish.raised = "";
    
    if (mainFish.wholeFishWeight !== null && mainFish.wholeFishWeight !== undefined) {
        let wholeFishWeight = await WholeFishWeight.findOne({ id: mainFish.preparation });
        if (wholeFishWeight !== undefined) mainFish.wholeFishWeight = wholeFishWeight.name;
        else mainFish.wholeFishWeight = '';
    }
    else mainFish.wholeFishWeight = '';

    return mainFish;
}

module.exports = {

    getTRW,

    addFish: async (req, res) => {
        try {
            let body = req.body;
            let product = await Fish.create(body).fetch();
            let store = await Store.findOne(product.store).populate('owner')
            if (product) {
                await MailerService.newProductAddedAdminNotified(product, store.owner);
                await MailerService.newProductAddedSellerNotified(product, store.owner);
                //await require("./../../mailer").sendEmailNewProductAdded(product,store.owner);
                //await require("./../../mailer").sendEmailNewProductAddedSeller(product,store.owner);
                res.json({ product })
            }
            else {
                res.serverError({ message: "error saving product" });
            }
        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    addFishWithVariations: async (req, res) => {
        try {
            let body = req.body;
            let seafood_sku = await sails.helpers.generateSku(
                body.store,
                body.parentType,
                body.specie,
                body.processingCountry
            );
            console.log("\n\n\n", seafood_sku, "\n\n\n");

            let newProduct = {
                type: body.type,
                store: body.store,
                name: body.name,
                price: { //for backward compatibility
                    type: "USD",
                    value: body.variations[0].prices[0].price, 
                    description: body.variations[0].prices[0].price + " for pack"
                },
                weight: {
                    type: "kg",
                    value: "0"
                },
                descriptor: body.descriptor,
                country: body.country,
                processingCountry: body.processingCountry,
                city: body.city,
                foreign_fish: body.foreign_fish,
                perBox: body.perBox,
                boxWeight: body.boxWeight,
                minimumOrder: body.minimumOrder,
                maximumOrder: body.maximumOrder,
                raised: body.raised,
                treatment: body.treatment,
                unitOfSale: body.unitOfSale,
                seller_sku: body.seller_sku,
                seafood_sku: seafood_sku, // sku generated by the helper
                mortalityRate: body.mortalityRate,
                waterLostRate: body.waterLostRate,
                status: body.role == 0 ? "5c0866f9a0eda00b94acbdc2" : "5c0866e4a0eda00b94acbdc0", // if admin is adding the product the status is approved otherwise is pending
                brandname: body.brandName,
                hsCode: body.hsCode,
                // acceptableSpoilageRate: body.acceptableSpoilageRate
            }



            let mainFish = await Fish.create(newProduct).fetch();

            if (mainFish) {
                await Promise.all(body.variations.map(async (variation, index) => {
                    let skuVar = `${seafood_sku}`;
                    //Para cuando tiene wholeFishWeight y fishPreparation
                    if (variation.hasOwnProperty('wholeFishWeight') === true && variation.hasOwnProperty('fishPreparation') === true) {
                        let whole = await WholeFishWeight.findOne({ id: variation.wholeFishWeight });
                        if (whole !== undefined)
                            skuVar += "-"+ whole.name.substring(0, 1);
                    } else if (variation.hasOwnProperty('fishPreparation') === true && variation.fishPreparation === "5c93c01465e25a011eefbcc4") {
                        //Para fillete
                        skuVar += "-"+ 1;
                    } else if (variation.hasOwnProperty('fishPreparation') === true) {
                        //Para trimmings salmon
                        let trimm = await TrimmingType.findOne({ id: variation.fishPreparation });
                        if (trimm !== undefined)
                            skuVar += "-"+ trimm.name.slice(-1);
                    }

                    let newVariation = {
                        sku: skuVar,
                        fishPreparation: variation.fishPreparation,
                        fish: mainFish.id
                    }

                    if (variation.hasOwnProperty('wholeFishWeight')) {
                        newVariation['wholeFishWeight'] = variation.wholeFishWeight;
                    }

                    newVariation = await Variations.create(newVariation).fetch();


                    if (newVariation) {
                        await Promise.all(
                            variation.prices.map(async (varPrice, indexPrice) => {
                                await VariationPrices.create({
                                    min: varPrice.min,
                                    max: varPrice.max,
                                    price: varPrice.price,
                                    variation: newVariation.id
                                })
                            })
                        )

                    } else {
                        res.status(400).json({ message: "Error saving the a variation", newVariation });
                    }



                })
                );
            } else { // if there is an error creating the main product
                res.status(400).json({ message: "Error saving the product", mainFish });
            }


            //let variations = json.stringfy( req.body.variations ) ;
            mainFish = await getTRW(mainFish);
            let store = await Store.findOne(mainFish.store).populate('owner')
            if ( body.role == 0 ) { // if admin add the product is not needed to sent email for new product
                await MailerService.newProductAddedSellerNotified(mainFish, store.owner);
                await MailerService.newProductAddedAdminNotified(mainFish, store.owner);
            }
            res.json(mainFish);

        } catch (error) {
            console.error(error);
            res.serverError(error);
        }
    },

    updateFishWithVariations: async (req, res) => {
        try {
            let body = req.body;
            // let update fish information
            let fishBody = {
                type: body.type,
                descriptor: body.descriptor,
                name: body.name,
                description: body.description,
                country: body.country,
                processingCountry: body.processingCountry,
                city: body.city,
                weight: body.weight,
                perBox: body.perBox,
                foreign_fish: body.foreign_fish,
                minimumOrder: body.minimumOrder,
                maximumOrder: body.maximumOrder,
                // acceptableSpoilageRate: body.acceptableSpoilageRate,
                raised: body.raised,
                unitOfSale: body.unitOfSale,
                treatment: body.treatment,
                seller_sku: body.seller_sku,
                mortalityRate: body.mortalityRate,
                waterLostRate: body.waterLostRate,
                brandname: body.brandName,
                boxWeight: body.boxWeight,
                hsCode: body.hsCode
            }

            let fishUpdated = await Fish.update({ id: body.idProduct }).set(
                fishBody
            ).fetch();
            // let go variations information
            await Promise.all(body.variations.map(async variation => {
                let variationBody = {
                    fishPreparation: variation.fishPreparation,
                }
                if (variation.hasOwnProperty('wholeFishWeight')) {
                    variationBody['wholeFishWeight'] = variation.wholeFishWeight;
                }
                let newVariation;
                if (variation.hasOwnProperty('idVariation')) {
                    // update
                    newVariation = await Variations.update({ id: variation.idVariation }).set(variationBody).fetch();
                } else {
                    //create
                    let skuVar = `${fishUpdated[0].seafood_sku}`;
                    //Para cuando tiene wholeFishWeight y fishPreparation
                    if (variation.hasOwnProperty('wholeFishWeight') === true && variation.hasOwnProperty('fishPreparation') === true) {
                        let whole = await WholeFishWeight.findOne({ id: variation.wholeFishWeight });
                        if (whole !== undefined)
                            skuVar += "-"+ whole.name.substring(0, 1);
                    } else if (variation.hasOwnProperty('fishPreparation') === true && variation.fishPreparation === "5c93c01465e25a011eefbcc4") {
                        //Para fillete
                        skuVar += "-"+ 1;
                    } else if (variation.hasOwnProperty('fishPreparation') === true) {
                        //Para trimmings salmon
                        let trimm = await TrimmingType.findOne({ id: variation.fishPreparation });
                        if (trimm !== undefined)
                            skuVar += "-"+ trimm.name.slice(-1);
                    }
                    let sku = `${fishUpdated[0].seafood_sku}`;
                    variationBody['sku'] = skuVar;
                    variationBody['fish'] = body.idProduct;
                    newVariation = await Variations.create(variationBody).fetch();
                }

                // let update pricing information
                await Promise.all(variation.prices.map(async price => {
                    let priceBody = {

                        min: price.min,
                        max: price.max,
                        price: price.price
                    }
                    if (price.hasOwnProperty('id')) {
                        // lets update
                        await VariationPrices.update({ id: price.id }).set(priceBody);
                    } else {
                        // lets create
                        console.log("\n\n", newVariation, "\n", variation);
                        let idVar = "";
                        if (Object.prototype.toString.call(newVariation) === '[object Array]') {
                            idVar = newVariation.length > 0 ? newVariation[0].id : variation.id;
                        } else {
                            idVar = newVariation.id ? newVariation.id : variation.id;
                        }
                        priceBody['variation'] = idVar;
                        await VariationPrices.create(priceBody);
                    }

                }))


            }))


            //let delete variation
            if (body.hasOwnProperty('pricesDeleted')) {
                await VariationPrices.destroy({ id: { in: body.pricesDeleted } });
            }

            //let delete variation
            if (body.hasOwnProperty('variationsDeleted')) {
                await Variations.destroy({ id: { in: body.variationsDeleted } });
            }


            res.json(fishUpdated);

        } catch (error) {
            res.serverError(error);
        }
    },

    getFishWithVariations: async (req, res) => {
        try {
            let fishID = req.param('id');
            let fish = await Fish.findOne({ id: fishID }).populate('status').populate('store').populate('type').populate('treatment').populate('raised');//.populate('descriptor')
            
            if (fish === undefined) {
                return res.status(200).json({});
            }

            if( fish.hasOwnProperty('perBox') && fish.perBox === true) { // adding min/max boxes 
                fish['minBox'] = fish.minimumOrder / fish.boxWeight;
                fish['maxBox'] = fish.maximumOrder / fish.boxWeight;
            } else {
            delete fish['maxBox'];
	    }
            let unixNow = Math.floor(new Date());
            let variations = await Variations.find({ 'fish': fish.id }).populate('fishPreparation').populate('wholeFishWeight');

            let useOne = false;
            if (variations.length == 0) {
                useOne = true;
            }
            fish['useOne'] = useOne;
            headAction = false;
            headOff = false;
            headOn = false;
            weights =
                {
                    on: {
                        keys: []
                    },
                    off: {
                        keys: []
                    }
                }
                ;
            let weightsTrim = {};
            let isTrimms = useOne === true ? false : (variations[0].wholeFishWeight === undefined || variations[0].wholeFishWeight === null) && fish.type.parent === '5bda361c78b3140ef5d31fa4';
            let weightsFilleted = [];

            await Promise.all(
                variations.map(async variation => {
                    console.log(variation.id);

                    let inventory = await FishStock.find().where({
                        "date": { '>': unixNow },
                        "variations": variation.id
                    } ).sort( 'date DESC' ).populate('variations');                    
                    
                    let minMaxInventory = [];
                    inventory.map( item => {
                        minMaxInventory.push( (item.quantity - item.purchased) );
                    } )

                    
                    if( minMaxInventory.length === 0 ) {
                        /*fish['minimumOrder'] = 0;
                        fish['maximumOrder'] = 0;
                        fish['minBox'] = 0;
                        fish['maxBox'] = 0;*/
                        //fish['coomingsoon'] = '1';
                        fish['outOfStock'] = true;
                    } else if ( fish.hasOwnProperty('perBox') && fish.perBox === true) { // adding min/max boxes     
                        fish['outOfStock'] = false;
                        fish['maxBox'] = Math.max.apply(null, minMaxInventory) / fish.boxWeight;
                        if( fish['minBox'] > fish['maxBox'] ) {
                            fish['minBox'] = fish['maxBox'];
                        }                        
                    } else {                      
                        fish['outOfStock'] = false;  
                        fish['maximumOrder'] = Math.max.apply(null, minMaxInventory);                                                    
			            fish['maxBox'] = Math.max.apply(null, minMaxInventory);
                    }

                    if ( fish['minimumOrder'] > fish['maximumOrder'] ) {
                        fish['minimumOrder'] = fish['maximumOrder'];
                    }
                    console.log(variation['fishPreparation']);
                    if (isTrimms === false) {
                        if (variation['fishPreparation']['id'] === '5c93bff065e25a011eefbcc2') {
                            headAction = true;
                            headOn = true;
                            weights.on.keys.push(variation.wholeFishWeight.id)
                            weights.on[variation.wholeFishWeight.id] = [];
                        }

                        if (variation['fishPreparation']['id'] === '5c93c00465e25a011eefbcc3') {
                            headAction = true;
                            headOff = true;
                            weights.off.keys.push(variation.wholeFishWeight.id)
                            weights.off[variation.wholeFishWeight.id] = [];
                        }


                    } else {
                        weightsTrim[variation.fishPreparation.id] = [];
                        headAction = false;
                    }


                    let prices = await VariationPrices.find({ 'variation': variation.id });
                    let minLimit = fish.minimunOrder;
                    prices = prices.map((row, indexPrice) => {
                        if( minMaxInventory.length >= 0 ) {
                            row.max =  Math.max.apply(null, minMaxInventory) / fish.boxWeight;;                            
                        } else {
                            /*row.min = 0;
                            row.max = 0;*/
                            fish['cooming_soon'] = '1';
                        }
                        let maxLimit = fish.maximumOrder;;
                        /*if (indexPrice < (prices.length - 1)) { //is not the last price 
                            maxLimit = prices[(indexPrice + 1)].min;
                        }*/
			row['max'] = maxLimit;
                        let optionSlides = {
                            floor: row.min,
                            ceil: minLimit,
                            maxLimit: maxLimit,
                            step: 1,
                            noSwitching: true
                        },
                            sld = {
                                idVariation: variation.id,
                                id: row.id,
                                min: row.min,
                                max: maxLimit ? maxLimit : row.max,//row.max,
                                price: row.price,
                                options: optionSlides
                            };
                        if (isTrimms == false) {
                            if (variation['fishPreparation']['id'] === '5c93bff065e25a011eefbcc2') //head on
                                weights.on[variation.wholeFishWeight.id].push(sld);
                            else if (variation['fishPreparation']['id'] === '5c93c00465e25a011eefbcc3') //head off
                                weights.off[variation.wholeFishWeight.id].push(sld);
                            else { //este es para filleted no es trimms y es wholeFishAction false
                                weightsFilleted.push(sld);
                            }

                        } else {
                            weightsTrim[variation.fishPreparation.id].push(sld);
                        }

                        minLimit = row.max;
                        return row;
                    })
                    variation['prices'] = prices;
                })
            );

            if (headOff && headOff)
                fish['head'] = 'both';
            else if (headOn)
                fish['head'] = 'on';
            else if (headOff)
                fish['head'] = 'off';
            else
                fish['head'] = '';

            //Ignorar los variations que no tiene prices
            for (let key of weights.on.keys) {
                if (weights.on[key] !== undefined && weights.on[key] !== null)
                    weights.on[key] = weights.on[key].length > 0 ? weights.on[key] : undefined;
            }
            console.log(weights.on.keys);
            weights.on.keys = weights.on.keys.filter(it => {
                console.log(weights.on[it]);
                return weights.on[it] !== undefined && weights.on[it] !== null && weights.on[it].length > 0;
            });
            console.log(weights.on.keys);

            for (let key of weights.off.keys) {
                if (weights.off[key] !== undefined && weights.off[key] !== null)
                    weights.off[key] = weights.off[key].length > 0 ? weights.off[key] : undefined;
            }
            weights.off.keys = weights.off.keys.filter(it => {
                return weights.off[it] !== undefined && weights.off[it] !== null && weights.off[it].length > 0;
            });
            fish['headAction'] = headAction;
            fish['wholeFishAction'] = headAction;
            fish['weights'] = weights;
            fish["weightsTrim"] = weightsTrim;
            fish["weightsFilleted"] = weightsFilleted;
            fish['variations'] = variations;
            fish["isTrimms"] = isTrimms;

            res.status(200).json(fish);

        } catch (error) {
            res.serverError(error);
        }
    },

    // getFishWithVariations by weight, price, category, sub category, specie
    filterFishWithVariations: async (req, res) => {
        try {
            filterByPricesVariations = false;
            filterByVariations = false;
            filterByFish = false;
            let prices_fishes_ids = [];
            let variations_fishes_ids = [];
            let fishes_ids = [];

            let fish_where = {};
            let variation_where = {}; // variation where
            let price_where = {}; // variation price where
            // start variation price filters
            if (req.body.hasOwnProperty('minPrice') && req.body.hasOwnProperty('maxPrice')) {
                let req_min_price = req.body.minPrice;
                let req_max_price = req.body.maxPrice;
                if (req_min_price !== '0' && req_max_price !== '0') {
                    filterByPricesVariations = true;
                    price_where['price'] = { ">": req_min_price, "<": req_max_price };
                } else if (req_min_price !== '0') {
                    filterByPricesVariations = true;
                    let req_min_price = req.body.minPrice;
                    price_where['price'] = { ">": req_min_price };
                } else if (req_max_price !== '0') {
                    filterByPricesVariations = true;
                    let req_max_price = req.body.maxPrice;
                    price_where['price'] = { "<": req_max_price };
                }
            }

            if (req.body.hasOwnProperty('weight')) {
                if (req.body.weight !== '0') {
                    filterByPricesVariations = true;
                    let req_weight = req.body.weight;
                    price_where['min'] = { "<": req_weight };
                    price_where['max'] = { ">": req_weight };
                }
            }

            //filter by price
            let variations_ids = [];
            let prices;
            if (filterByPricesVariations) {
                prices = await VariationPrices.find().where(
                    price_where
                )
                //addding variations in filter by prices
                prices.map(element => {
                    variations_ids.push(element.variation);
                })
            }
            // end variation price filters


            // start variation filters
            if (req.body.hasOwnProperty('preparation')) {
                if (req.body.preparation.length > 0) {
                    variation_where['fishPreparation'] = req.body.preparation;
                    console.log('1');
                    filterByVariations = true;
                }
            }
            if (req.body.hasOwnProperty('wholeFishWeight')) {
                if (req.body.wholeFishWeight.length > 0) {
                    variation_where['wholeFishWeight'] = req.body.wholeFishWeight;
                    console.log('2');
                    filterByVariations = true;
                }
            }


            if (filterByPricesVariations) {
                variation_where['id'] = variations_ids;
            }

            let variations;
            if ((filterByPricesVariations || filterByVariations)) {
                console.log('variation_where', variation_where);
                console.log('filterByPricesVariations', filterByPricesVariations);
                console.log('filterByVariations', filterByVariations);
                variations = await Variations.find().where(variation_where);
                variations.map(variation => {
                    variations_fishes_ids.push(variation.fish);
                })
                //if( variations_fishes_ids.length > 0 ){
                fish_where['id'] = variations_fishes_ids
                //}
            }
            // end variation filters


            // start fish filters
            if (req.body.hasOwnProperty('country')) {
                if (req.body.country !== '0')
                    fish_where['country'] = req.body.country;
            }
            if (req.body.hasOwnProperty('raised')) {
                if (req.body.raised.length > 0)
                    fish_where['raised'] = req.body.raised;
            }
            if (req.body.hasOwnProperty('treatment')) {
                if (req.body.treatment.length > 0)
                    fish_where['treatment'] = req.body.treatment;
            }

	    if (req.body.hasOwnProperty('cooming_soon')) {
                if (req.body.cooming_soon.length > 0)
                    fish_where['cooming_soon'] = req.body.cooming_soon;
            }

            let req_minimumOrder = req.body.minimumOrder;
            let req_maximumOrder = req.body.maximumOrder;
            if (req_minimumOrder !== '0' && req_maximumOrder !== '0') {                
                fish_where['minimumOrder'] = { ">=": req_minimumOrder, "<=": req_maximumOrder };
                fish_where['maximumOrder'] = { ">=": req_minimumOrder, "<=": req_maximumOrder };
            } else if (req_minimumOrder !== '0') {                
                fish_where['minimumOrder'] = { ">=": req_minimumOrder };
                fish_where['maximumOrder'] = { ">=": req_minimumOrder };
            } else if (req_maximumOrder !== '0') {
                fish_where['minimumOrder'] = { ">=": req_maximumOrder };
                fish_where['maximumOrder'] = { "<=": req_maximumOrder };
            }

            let category = req.body.category;
            let subcategory = req.body.subcategory;
            let subspecies = req.body.subspecies;
            let descriptor = req.body.descriptor;

            if (descriptor !== '0') {
                fish_where['descriptor'] = descriptor;
            } else if (subspecies !== '0') {
                let descriptorChilds = [];

                level1 = await FishType.find({
                    where: { parent: subspecies }
                });
                //                console.log( 'level1', level1 );

                await Promise.all(level1.map(async value1 => {
                    descriptorChilds.push(value1.id);

                    level2 = await FishType.find({ parent: value1.id });
                    //                  console.log( 'level2', level2 );


                    //return categoryChilds;
                }));
                fish_where['type'] = subspecies;
            } else if (subcategory !== '0') {

                //            console.log( 'parent' )
                //condWhere.where['type'] =;
                let categoryChilds = [];
                categoryChilds.push(subcategory);
                level1 = await FishType.find({
                    where: { parent: subcategory }
                });
                //          console.log( 'level1', level1 );

                await Promise.all(level1.map(async value1 => {
                    categoryChilds.push(value1.id);

                    level2 = await FishType.find({ parent: value1.id });
                    //            console.log( 'level2', level2 );


                    return categoryChilds;
                }));

                fish_where['type'] = categoryChilds;
            } else if (category !== '0') {
                console.log('parent')
                //condWhere.where['type'] =;
                let categoryChilds = [];
                categoryChilds.push(category);
                level1 = await FishType.find({
                    where: { parent: category }
                });
                //                console.log( 'level1', level1 );

                await Promise.all(level1.map(async value1 => {
                    categoryChilds.push(value1.id);

                    level2 = await FishType.find({ parent: value1.id });
                    //                    console.log( 'level2', level2 );

                    await Promise.all(level2.map(async value2 => {
                        categoryChilds.push(value2.id);

                        level3 = await FishType.find({ parent: value2.id });
                        //                        console.log( 'level3', level3 );
                        level3.map(value3 => {
                            categoryChilds.push(value3.id);
                        })
                        return categoryChilds;

                    }))

                    return categoryChilds;
                }));

                fish_where['type'] = categoryChilds;
            }
            fish_where['status'] = '5c0866f9a0eda00b94acbdc2';
            // end fish filters
            console.log('fish_where', fish_where);
            //return res.json( prices );
            //prices.map( price => {
            //   prices_fishes_ids.push(price.variation.fish);
            //} )            
            //let fishes = await sails.helpers.getVariableProduct( prices_fishes_ids )
            let fishes = await Fish.find(fish_where);

            let products_ids = [];
            fishes.map((item) => {
                products_ids.push(item.id);
            });

            let productos = [];
            variation_where['fish'] = products_ids;
            let res_variations = await Variations.find(variation_where).populate('fish').populate('fishPreparation').populate('wholeFishWeight');
            console.log('variations', res_variations.length);
            await Promise.all(res_variations.map(async function (m) {

                //get min max price
                let priceVariation = await VariationPrices.find({ variation: m.id });
                let minMax = [];
                priceVariation.map((pv) => {
                    minMax.push(pv.min);
                    minMax.push(pv.max);
                })

                m['max'] = Math.max.apply(null, minMax) // 4
                m['min'] = Math.min.apply(null, minMax) // 1

                //lets recreate old json format with Fish at the top and inside the variations
                let fish = m.fish;

		if( fish.hasOwnProperty('perBox') && fish.perBox === true) { // adding min/max boxes 
                  fish['minBox'] = fish.minimumOrder / fish.boxWeight;
                  fish['maxBox'] = fish.maximumOrder / fish.boxWeight;
            	}

                let variation = m;
                delete variation.fish;
                m = fish;
                //console.log(fish);
                m['variation'] = variation;

                if (m.store === null)
                    return m;

                m.store = await Store.findOne({ id: m.store }).populate('owner');
                //m.store.owner = await User.findOne({ id: m.store.owner });            
                //m.shippingCost =  await require('./ShippingRatesController').getShippingRateByCities( m.city, m.weight.value ); 
                productos.push(m);
                return m;
            }));

            return res.json(productos)


        } catch (error) {
            res.serverError(error);
        }
    },

    getfishByWeight: async (req, res) => {
        try {
            let weight = req.body.weight;


        } catch (error) {
            res.serverError(error);
        }
    },

    getAllPagination: async function (req, res) {
        try {
            let start = Number(req.params.page);
            --start;
            let publishedProducts = await Fish.find({ status: '5c0866f9a0eda00b94acbdc2' }).sort('name ASC').paginate({ page: start, limit: req.params.limit });
            let products_ids = [];
            publishedProducts.map((item) => {
                products_ids.push(item.id);
            });
            console.log('products_ids', products_ids);
            //let productos = await Fish.find( {status: '5c0866f9a0eda00b94acbdc2'} ).populate("type").populate("store").populate('status').paginate({ page: start, limit: req.params.limit });
            let productos = [];
            let variations = await Variations.find({ fish: products_ids }).populate('fish').populate('fishPreparation').populate('wholeFishWeight');
            console.log('variations', variations.length);
            let unixNow = Math.floor(new Date());
            await Promise.all(variations.map(async function (m) {
                let inventory = await FishStock.find().where({
                    "date": { '>': unixNow },
                    "variations": m.id
                } ).sort( 'date DESC' ).populate('variations');
                
                let minMaxInventory = [];
                inventory.map( item => {
                    minMaxInventory.push( (item.quantity - item.purchased) );
                } )

                //get min max price
                let priceVariation = await VariationPrices.find({ variation: m.id });
                let minMax = [];
                priceVariation.map((pv) => {
                    minMax.push(pv.min);
                    minMax.push(pv.max);
                })
                m['inventory'] = inventory;
                m['max'] = Math.max.apply(null, minMax) // 4
                m['min'] = Math.min.apply(null, minMax) // 1
		
                if( minMaxInventory.length > 0 ) {
                    m['max'] = Math.max.apply(null, minMaxInventory) // 4
                    m.fish['maximumOrder'] = Math.max.apply(null, minMaxInventory);
                    m['outOfStock'] = false;
                } else {
                    /*m['max'] = 0;
                    m['min'] = 0;*/
                    //m['cooming_soon'] = '1';
                    m['outOfStock'] = true;
                }

                //lets recreate old json format with Fish at the top and inside the variations
                let fish = m.fish;
                if( fish.hasOwnProperty('perBox') && fish.perBox === true) { // adding min/max boxes 
                    fish['minBox'] = fish.minimumOrder / fish.boxWeight;
                    fish['maxBox'] = fish.maximumOrder / fish.boxWeight;
                    
                    if( minMaxInventory.length > 0 && Math.max.apply(null, minMaxInventory) > 0 ) {
                        m['maxBox'] = Math.max.apply(null, minMaxInventory) / fish.boxWeight // 4
                    } else {
                        /*m['maxBox'] = 0;
                        m['minBox'] = 0;*/
                        m['cooming_soon'] = '1';
                    }
                }

                
                let variation = m;
                delete variation.fish;
                m = fish;
                //console.log(fish);
                m['variation'] = variation;

                if (m.store === null)
                    return m;

                m.store = await Store.findOne({ id: m.store }).populate('owner');
                //m.store.owner = await User.findOne({ id: m.store.owner });            
                //m.shippingCost =  await require('./ShippingRatesController').getShippingRateByCities( m.city, m.weight.value ); 
                productos.push(m);
                return m;
            }));
            productos = productos.sort(function IHaveAName(a, b) { // non-anonymous as you ordered...
                return b.name < a.name ?  1 // if b should come earlier, push a to end
                     : b.name > a.name ? -1 // if b should come later, push a to begin
                     : -1;                   // a and b are equal
            });


            /*productos = await Promise.all(productos.map(async function (m) {
                if (m.store === null)
                    return m;
                m.store.owner = await User.findOne({ id: m.store.owner });            
                m.shippingCost =  await require('./ShippingRatesController').getShippingRateByCities( m.city, m.weight.value ); 
                return m;
            }));*/

            let arr = await Fish.find({ status: '5c0866f9a0eda00b94acbdc2' }).sort('name ASC'),
                page_size = Number(req.params.limit), pages = 0;
            console.log(arr.length, Number(arr.length / page_size));
            if (parseInt(arr.length / page_size, 10) < Number(arr.length / page_size)) {
                pages = parseInt(arr.length / page_size, 10) + 1;
            } else {
                pages = parseInt(arr.length / page_size, 10)
            }

            res.json({ productos, pagesNumber: pages });
        }
        catch (e) {
            res.serverError(e);
        }
    },

    customWhere: async function (req, res) {
        try {

            var db = Fish.getDatastore().manager;

            // Now we can do anything we could do with a Mongo `db` instance:
            var fish = db.collection(Fish.tableName);

            if (req.params.hasOwnProperty("where"))
                where = JSON.parse(req.params.where);
            else
                res.json({ message: "where not correct" });

            let productos = await fish.find(where);

            res.json(productos);
        }
        catch (e) {
            res.serverError(e);
        }
    },

    search: async function (req, res) {
        try {

            var db = Fish.getDatastore().manager;

            // Now we can do anything we could do with a Mongo `db` instance:
            var fish = db.collection(Fish.tableName);
            console.log(req.param("search"));
            let pages;
            let productos = await new Promise((resolve, reject) => {
                fish.find({
                    $or:
                        [
                            { name: { '$regex': '^.*' + req.param("search") + '.*$', '$options': 'i' } },
                            { description: { '$regex': '^.*' + req.param("search") + '.*$', '$options': 'i' } }
                        ]
                })
                    .toArray(async (err, arr) => {
                        if (err) { return reject(err); }

                        arr = await Promise.all(arr.map(async function (it) {
                            if (it.store === null)
                                return it;

                            it.store = await Store.findOne({ id: it.store.toString() }).populate("owner");
                            return it;
                        }));
                        if (arr.length > 0) {
                            let page_number = Number(req.param("page"));
                            let page_size = Number(req.param("limit"));
                            console.log(arr.length, Number(arr.length / page_size));
                            if (parseInt(arr.length / page_size, 10) < Number(arr.length / page_size)) {
                                pages = parseInt(arr.length / page_size, 10) + 1;
                            } else {
                                pages = parseInt(arr.length / page_size, 10)
                            }
                            --page_number; // because pages logically start with 1, but technically with 0
                            arr = arr.slice(page_number * page_size, (page_number + 1) * page_size);
                        }
                        resolve(arr);
                    });
            });

            res.json({ fish: productos, pagesCount: pages });

            /*let productos = await Fish.find({name: {contains: req.param("name") } }).populate("type");
            
            res.json(productos);*/
        }
        catch (e) {
            res.serverError(e);
        }
    },

    getSuggestions: async (req, res) => {
        try {

            let name = req.param("name");

            var db = Fish.getDatastore().manager;
            var fish = db.collection(Fish.tableName);

            console.log(req.param("search"));
            let fishs = await new Promise((resolve, reject) => {
                fish.find({ status: '5c0866f9a0eda00b94acbdc2', name: { '$regex': '^.*' + name + '.*$', '$options': 'i' } })
                    .toArray(async (err, arr) => {
                        if (err) { return reject(err); }

                        resolve(arr);
                    });
            });

            let countAndFish = [];
            fishs.map(function (it) {
                let index = countAndFish.findIndex((t) => { if (t.name === it.name) return true; else return false; });
                if (
                    index === -1
                ) {
                    let f = { name: it.name, id: it._id };
                    f.count = 1;
                    countAndFish.push(f);
                } else {
                    countAndFish[index].count += 1;
                }

                return null;
            });

            res.json(countAndFish);

        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    getXMultipleID: async function (req, res) {
        try {
            let ids = false;
            try {
                ids = JSON.parse(req.params.ids);
                if (Object.prototype.toString.call(ids) !== "[object Array]") {
                    throw new Error("ids not is Array");
                }
            }
            catch (e) {
                console.error(e);
            }

            if (ids === false)
                return res.json({ message: "ids not correct array" });

            let productos = [];
            for (let id of ids) {
                let prod = await Fish.findOne({ id: id }).populate("type");
                productos.push(prod);
            }

            res.json(productos);
        }
        catch (e) {
            res.serverError(e);
        }
    },

    delete: async (req, res) => {
        try {

            let id = req.param("id");
            if (id === "" || id === undefined)
                return res.status(500).send("not id");

            let fish = await Fish.findOne({ id });
            if (fish === undefined) {
                return res.status(400).send("fish not found!");
            }

            //check if had records in the carts
            let hasRecords = await ItemShopping.find({ fish: id });

            if (hasRecords.length > 0) {
                // we can't deleted from the database so we are going to update the status of the fish
                let updatedFish = await Fish.update({ id: id }, { status: '5c45f73f1d75b800924b4c39' });
                res.status(200).json(updatedFish);
            } else {
                let namefile, dirname;
                if (fish.hasOwnProperty("imagePrimary") && fish.imagePrimary !== "" && fish.imagePrimary !== null) {
                    namefile = fish.imagePrimary.split("/");
                    namefile = namefile[namefile.length - 2];
                    console.log(IMAGES, fish.id, namefile);
                    dirname = path.join(IMAGES, "primary", fish.id, namefile);
                    console.log(dirname);
                    if (fs.existsSync(dirname)) {
                        console.log("exits primary");
                        fs.unlinkSync(dirname);
                        //dirname = path.join(IMAGES, "primary", fish.id);
                        //fs.unlinkSync(dirname);
                    }
                }

                if (fish.hasOwnProperty("images") && fish.iamges !== null && Object.prototype.toString.call(fish.images) === "[object Array]") {
                    for (let file of fish.images) {

                        namefile = file.filename;
                        dirname = path.join(IMAGES, fish.id, namefile);
                        console.log(dirname);
                        if (fs.existsSync(dirname)) {
                            console.log("exists");
                            fs.unlinkSync(dirname);
                        }
                    }

                    //dirname = path.join(IMAGES, fish.id);
                    //if (fs.existsSync(dirname)) {
                    //    console.log("exists");
                    //    fs.unlinkSync(dirname);
                    //}
                }

                await Fish.destroy({ id });
                res.json(fish);
            }


        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    getXTypeWithDataEspecified: async (req, res) => {
        try {

            let type = req.param("type");

            //Para cagar los items de cada carrito cargado
            async function getItemsCart(shoppingCart) {
                let items = await ItemShopping.find({ shoppingCart: shoppingCart.id }).populate("fish", { where: { status: '5c0866f9a0eda00b94acbdc2' } });
                items = items.filter(function (it) {
                    return it.fish.type === type;
                });

                //Cargamos el comprador y la tienda
                items = items.map(function (it) {
                    return {
                        id: it.fish.id,
                        name: it.fish.name,
                        quantity: it.quantity
                    };
                });

                return items;
            }

            let itemsFish = [];
            let cartsPaid = await ShoppingCart.find({ status: "paid" }).populate("buyer");
            for (let cart of cartsPaid) {
                let its = await getItemsCart(cart);
                itemsFish = itemsFish.concat(its);
            }

            let itemsP = [];
            for (let it of itemsFish) {
                let index = itemsP.findIndex(function (ite) {
                    return ite.name === it.name;
                });

                if (index === -1) {
                    let parser = it;
                    parser.quantity = [it.quantity];
                    itemsP.push(parser);
                } else {

                    let find = false;
                    for (let i = 0; i < itemsP[index].quantity.length; i++) {
                        if (itemsP[index].quantity[i].type === it.quantity.type) {
                            find = true;
                            itemsP[index].quantity[i].value += it.quantity.value;
                            break;
                        }
                    }

                    if (find === false) {
                        itemsP[index].quantity.push(it.quantity);
                    }
                }
            }

            res.json(itemsP);

        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    getWithDataEspecified: async (req, res) => {
        try {

            //Para cagar los items de cada carrito cargado
            async function getItemsCart(shoppingCart) {
                let items = await ItemShopping.find({ shoppingCart: shoppingCart.id }).populate("fish", { where: { status: '5c0866f9a0eda00b94acbdc2' } });

                //Cargamos el comprador y la tienda
                items = await Promise.all(items.map(async function (it) {

                    it.fish = await Fish.findOne({ id: it.fish.id }).populate("type");
                    return {
                        quantity: it.quantity,
                        type: it.fish.type
                    };
                }));

                return items;
            }

            let itemsFish = [];
            let cartsPaid = await ShoppingCart.find({ status: "paid" });
            for (let cart of cartsPaid) {
                let its = await getItemsCart(cart);
                itemsFish = itemsFish.concat(its);
            }

            let itemsP = [];
            for (let it of itemsFish) {
                let index = itemsP.findIndex(function (ite) {
                    return ite.type.id === it.type.id;
                });

                if (index === -1) {
                    let parser = it;
                    parser.quantity = [it.quantity];
                    itemsP.push(parser);
                } else {

                    let find = false;
                    for (let i = 0; i < itemsP[index].quantity.length; i++) {
                        if (itemsP[index].quantity[i].type === it.quantity.type) {
                            find = true;
                            itemsP[index].quantity[i].value += it.quantity.value;
                            break;
                        }
                    }

                    if (find === false) {
                        itemsP[index].quantity.push(it.quantity);
                    }
                }
            }

            res.json(itemsP);

        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    saveMulti: async (req, res) => {
        try {
            let products = req.body.products;
            for (let pro of products) {
                await Fish.create(pro);
            }

            res.json({ msg: "success" })
        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    searchAvanced: async (req, res) => {
        try {

            let params = `
            name,
            country,
            fishType,
            raised,
            preparation,
            treatment`;

            let par = {};
            for (let p of await sails.helpers.parserNameParams(params)) {
                if (req.param(p) !== undefined) {
                    if ("fishType" === p) {
                        par["type"] = req.param(p);
                    } else
                        par[p] = { "contains": req.param(p) };
                }
            }
            console.log(par);

            let start = Number(req.params.page), page_size = Number(req.params.limit)
            --start;
            if (start < 0) start = 0;
            let productos = await Fish.find(par).populate("type").populate("store").paginate(start, page_size);

            let arr = await Fish.find(par).populate("type").populate("store"), pages = 0;
            console.log(arr.length, Number(arr.length / page_size));
            if (parseInt(arr.length / page_size, 10) < Number(arr.length / page_size)) {
                pages = parseInt(arr.length / page_size, 10) + 1;
            } else {
                pages = parseInt(arr.length / page_size, 10)
            }

            res.json({ productos, pagesNumber: pages, count: arr.length });

        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    getDistinctCountry: async (req, res) => {
        try {
            var db = Fish.getDatastore().manager;
            var fish = db.collection(Fish.tableName);
            //.find({
            let fishs = await new Promise((resolve, reject) => {
                fish.distinct("country", { status: new ObjectId('5c0866f9a0eda00b94acbdc2') },
                    function (err, docs) {
                        if (err) {
                            return reject(err);
                        }
                        if (docs) {
                            resolve(docs);
                        }
                    })
            });


            res.json(fishs);
        }
        catch (e) {
            console.error(e);
            res.serverError(e);
        }
    },

    filterProducts: async (req, res) => {
        try {
            let preparation = req.param('preparation');
            let treatment = req.param('treatment');
            let raised = req.param('raised');

            let country = req.param('country');
            let category = req.param('category');
            let subcategory = req.param('subcategory');
            let subspecies = req.param('subspecies');
            let descriptor = req.param('descriptor');

            let minimumOrder = req.body.minimumOrder;
            let maximumOrder = req.body.maximumOrder;
            let cooming_soon = req.param('cooming_soon');
            let minPrice = req.param('minPrice'); //price.value
            let maxPrice = req.param('maxPrice'); //price.value

            let condWhere = { where: { status: '5c0866f9a0eda00b94acbdc2' } };

            if (preparation !== '0' && preparation !== undefined && preparation.length != 0)
                condWhere.where['preparation'] = preparation;

            if (treatment !== '0' && treatment !== undefined && treatment.length != 0)
                condWhere.where['treatment'] = treatment;

            if (raised !== '0' && raised !== undefined && raised.length != 0)
                condWhere.where['raised'] = raised;

            if (country !== '0')
                condWhere.where['country'] = country;

	    if (maximumOrder !== '0' && minimumOrder !== '0' ) {
		condWhere.where['maximumOrder'] = { '>=': parseFloat(maximumOrder) };
		condWhere.where['minimumOrder'] = { '<=': parseFloat(minimumOrder) };
	    } else if (maximumOrder !== '0') {
                condWhere.where['maximumOrder'] = { '>=': parseFloat(maximumOrder) };
		condWhere.where['minimumOrder'] = { '<=': parseFloat(maximumOrder) };
	    } else if (minimumOrder !== '0') {
                condWhere.where['minimumOrder'] = { '<=': parseFloat(minimumOrder) };
		condWhere.where['maximumOrder'] = { '>=': parseFloat(minimumOrder) };
	    }
	    console.log( condWhere );
            if (cooming_soon !== '0') {
                condWhere.where['cooming_soon'] = cooming_soon;
            }

            console.log('before cats', condWhere);
            if (descriptor !== '0') {
                condWhere.where['descriptor'] = descriptor;
            } else if (subspecies !== '0') {
                let descriptorChilds = [];

                level1 = await FishType.find({
                    where: { parent: subspecies }
                });
                console.log('level1', level1);

                Promise.all(level1.map(async value1 => {
                    descriptorChilds.push(value1.id);

                    level2 = await FishType.find({ parent: value1.id });
                    console.log('level2', level2);


                    return descriptorChilds;
                }));
                //condWhere.where['descriptor'] = descriptorChilds;
                condWhere.where['type'] = subspecies;
            } else if (subcategory !== '0') {

                console.log('parent')
                //condWhere.where['type'] =;
                let categoryChilds = [];
                categoryChilds.push(subcategory);
                level1 = await FishType.find({
                    where: { parent: subcategory }
                });
                console.log('level1', level1);

                Promise.all(level1.map(async value1 => {
                    categoryChilds.push(value1.id);

                    level2 = await FishType.find({ parent: value1.id });
                    console.log('level2', level2);


                    return categoryChilds;
                }));

                condWhere.where['type'] = categoryChilds;
            } else if (category !== '0') {
                console.log('parent')
                //condWhere.where['type'] =;
                let categoryChilds = [];
                categoryChilds.push(category);
                level1 = await FishType.find({
                    where: { parent: category }
                });
                console.log('level1', level1);

                await Promise.all(level1.map(async value1 => {
                    categoryChilds.push(value1.id);

                    level2 = await FishType.find({ parent: value1.id });
                    console.log('level2', level2);

                    Promise.all(level2.map(async value2 => {
                        categoryChilds.push(value2.id);

                        level3 = await FishType.find({ parent: value2.id });
                        console.log('level3', level3);
                        level3.map(value3 => {
                            categoryChilds.push(value3.id);
                        })
                        return categoryChilds;

                    }))

                    return categoryChilds;
                }));

                condWhere.where['type'] = categoryChilds;
            }

            /*if( subcategory !== '0' ){
                condWhere.where['type'] = subcategory;                
            }else {
                if( category !== '0' ){
                    let categoryChilds = await FishType.find({
                        where: { parent: category, status: '5c0866f9a0eda00b94acbdc2' }
                    })
                    .then(function ( result ) {
                        return result.map( value => {
                            return value.id;
                        } )
                    })
                    .catch(function (error) {
                        console.log(error);
                        return res.serverError(error);
                    })
                    categoryIds = categoryChilds ;
                    categoryIds.push(category);
                    condWhere.where['type'] = categoryIds;
                }                
            }*/
            let fish_price_ids = '';
            if (minPrice !== '0' || maxPrice !== '0') {

                fish_price_ids = await Fish.native(function (err, collection) {
                    if (err) return res.serverError(err);
                    console.log('min', minPrice);
                    console.log('max', maxPrice);
                    //{status: '5c0866f9a0eda00b94acbdc2'},
                    let price_ids = collection.find(
                        {
                            $and: [

                                {
                                    "price.value": { $gte: parseInt(minPrice) }
                                },
                                {
                                    "price.value": { $lte: parseInt(maxPrice) }
                                }]
                        }, { "status": '5c0866f9a0eda00b94acbdc2' }).toArray(async function (err, results) {
                            if (err) return res.serverError(err);
                            //console.log( 'justids', results );
                            justIds = results.map((row) => {
                                return row._id.toString()
                            })
                            condWhere.where['id'] = justIds;

                            /*let fishes = await Fish.find(
                                condWhere
                            ).populate("type")
                            .then(function ( result ) {
                                let shippingRate = 
                                res.status(200).json( result );
                            }) */
                            let productos = await Fish.find(condWhere).populate("type").populate("store");
                            productos = await Promise.all(productos.map(async function (m) {
                                m.shippingCost = await require('./ShippingRatesController').getShippingRateByCities(m.city, m.weight.value);
                                if (m.store === null)
                                    return m;
                                m.store.owner = await User.findOne({ id: m.store.owner });

                                if( m.hasOwnProperty('perBox') && m.perBox === true) { // adding min/max boxes 
                                    m['minBox'] = m.minimumOrder / m.boxWeight;
                                    m['maxBox'] = m.maximumOrder / m.boxWeight;
                                }
                

                                return m;
                            }));
                            
                            res.status(200).json(productos);
                            return justIds;
                        });
                    return price_ids
                });
            } else {
                /*let fishes = await Fish.find(
                    condWhere
                ).populate("type")
                .then(function ( result ) {
                    res.status(200).json( result );
                })*/
                let productos = await Fish.find(condWhere).populate("type").populate("store");
                productos = await Promise.all(productos.map(async function (m) {
                    m.shippingCost = await require('./ShippingRatesController').getShippingRateByCities(m.city, m.weight.value);
                    if (m.store === null)
                        return m;
                    m.store.owner = await User.findOne({ id: m.store.owner });
                    return m;
                }));
                res.status(200).json(productos);
            }
            console.log( condWhere );             



        } catch (error) {
            console.log(error);
            res.serverError(error);
        }

    },

    generateSKU: async (req, res) => {
        let store = req.param('store_code');
        let category = req.param('category_code');
        let subcategory = req.param('subcategory_code');
        let country = req.param('country');

        let store_name = await Store.find(
            {
                where: {
                    "id": store
                }
            }
        )


        let country_name = await Countries.find(
            {
                where: {
                    "code": country
                }
            }
        )

        let category_name = await FishType.find(
            {
                where: {
                    "id": category
                }
            }
        )

        let subcategory_name = await FishType.find(
            {
                where: {
                    "id": subcategory
                }
            }
        )

        let fishes = await Fish.count({
            country: country,
            store: store,
            type: subcategory,
            country: country
        })

        let body = {
            store_name: store_name[0].name,
            country: country_name[0].name,
            category: category_name[0].name,
            sub: subcategory_name[0].name,
            country: country_name[0].name
        }
        fishes += 1;
        if (fishes < 10)
            fishes = '0' + fishes;

        res.status(200).json(`${store_name[0].name.substring(0, 3).toUpperCase()}-${category_name[0].name.substring(0, 3).toUpperCase()}-${subcategory_name[0].name.substring(0, 3).toUpperCase()}-${country_name[0].name.substring(0, 3).toUpperCase()}-${fishes}`);

    },

    updateStatus: async (req, res) => {
        try {
            let id = req.param("id");
            let statusID = req.param("statusID");

            let fishUpdated;
            //let fish = await Fish.update({id}, { status: statusID,statusReason:reason }).fetch();
            let fish = await Fish.findOne({ id }).populate('store');
            fish = await getTRW(fish);
            let store = await Store.findOne({ id: fish.store.id }).populate('owner');
            if (statusID == '5c0866f2a0eda00b94acbdc1') { //Not Approved
                let SFSAdminFeedback = req.body['message']; //req.param("SFSAdminFeedback")
                console.log(SFSAdminFeedback)
                if (SFSAdminFeedback && SFSAdminFeedback !== '') {
                    fishUpdated = await Fish.update({ id }, { status: statusID, SFSAdminFeedback: SFSAdminFeedback }).fetch();
                    //await require("./../../mailer").sendEmailProductRejected(store.owner, fish,SFSAdminFeedback);
                    await MailerService.newProductRejected(store.owner, fish, SFSAdminFeedback);
                }
                else {
                    res.serverError({ 'msg': "You need to provide a reason for not approved the product" })
                }
            } else if (statusID == '5c0866f9a0eda00b94acbdc2') { //Approved

                fishUpdated = await Fish.update({ id }, { status: statusID }).fetch();
                await MailerService.newProductAccepted(store.owner, fish);

                await sails.helpers.updateCategoryCount();
                //await require("./../../mailer").sendEmailProductApproved(store.owner, fish);
            }

            res.status(200).json(fishUpdated)
        } catch (error) {
            res.serverError(error);
        }
    },

    getPendingProducts: async (req, res) => {
        try {
            let countries = await Countries.find();
            let fishes = await Fish.find({ status: '5c0866e4a0eda00b94acbdc0' }).populate('store').populate('type');


            fishes = await Promise.all(fishes.map(async (it) => {
                try {
                    let owner = await User.findOne({ id: it.store.owner })


                    let fishID = req.param('fishID');

                    let level2 = it.type;

                    let descriptor = await FishType.findOne({ id: it.descriptor });


                    let level1 = await FishType.findOne({ id: level2.parent });

                    let level0 = await FishType.findOne({ id: level1.parent });

                    let parentsLevel = { level0, level1, level2, descriptor };
                    it.parentsLevel = parentsLevel;

                    await countries.map(async country => {
                        if (it.country == country.code) {
                            it.countryName = country.name;
                            console.log(country.name)

                            await country.cities.map(city => {
                                if (it.city == city.code) {
                                    it.cityName = city.name;
                                    console.log(city);
                                }
                            })
                        }
                        if (it.processingCountry == country.code) {
                            it.processingCountryName = country.name;
                        }
                    })

                    it.owner = {
                        id: owner.id,
                        email: owner.email,
                        firstName: owner.firstName,
                        lastName: owner.lastName,
                        location: owner.location,
                        dataExtra: owner.dataExtra
                    }
                }
                catch (e) {
                    console.error(e);
                }
                return it;
            }))


            res.status(200).json(fishes);
        } catch (error) {
            console.log(error);
            res.serverError(error);
        }
    },
    getItemCharges: async (req, res) => {
        try {
            let currentAdminCharges = await sails.helpers.currentCharges();
            let id = req.param('id');
            let variation_id = req.param('variation_id');
            let weight = req.param('weight');
            let in_AED = (req.param('in_AED') == "true");
            console.log('in_AED', in_AED);
            console.log('in_AED2', req.param('in_AED'));
            let charges = await sails.helpers.fishPricing(id, weight, currentAdminCharges, variation_id, in_AED);
	    let stock = await sails.helpers.getEtaStock( variation_id , weight );
            charges['eta'] = stock;
            res.status(200).json(charges);

        } catch (error) {
            console.log(error);
            res.serverError(error);
        }
    },

    getFishs: catchErrors(async (req, res) => {
        let fishstypes = await FishType.find().populate("childsTypes").populate("parentsTypes");
        fishstypes = await Promise.all(fishstypes.map(async (it) => {
            try {
                it.childsTypes = await getChildsTypes(it.childsTypes);
                it.parentsTypes = await getParentsTypes(it.parentsTypes);
            }
            catch (e) {
                console.error(e);
            }

            return it;
        }))
        res.json(fishstypes);
    })


};

getChildsTypes = async childs => {
    childs = await Promise.all(childs.map(async it => {
        it.child = await FishType.findOne({ id: it.child });
        return it;
    }));

    return childs;
};

getParentsTypes = async parents => {
    parents = await Promise.all(parents.map(async it => {
        it.parent = await FishType.findOne({ id: it.parent });
        return it;
    }));

    return parents;
}

